<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VRM Wareneingang – Kamera-OCR</title>
  <meta name="theme-color" content="#0b1220" />
  <link rel="manifest" href="manifest.json?v=9" />
  <style>
    :root { --bg:#0b1220; --card:#121a2b; --muted:#9fb0d0; --ok:#23c55e; --warn:#f59e0b; --err:#ef4444; --txt:#e6eefc; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--txt);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{padding:14px 16px;border-bottom:1px solid #1c2740;display:flex;justify-content:space-between;align-items:center}
    .badge{font-size:12px;padding:4px 8px;border-radius:999px;background:#0f1729;border:1px solid #1c2740;color:var(--muted)}
    main{padding:16px;max-width:1200px;margin:0 auto;display:grid;gap:16px}
    .card{background:#121a2b;border:1px solid #1c2740;border-radius:14px;padding:14px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    input[type="file"],select,button{background:#0f1729;color:var(--txt);border:1px solid #1c2740;border-radius:10px;padding:10px 12px}
    button{cursor:pointer} .primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:none}
    .hint{color:var(--muted);font-size:12px;margin-top:6px}
    video{width:100%;max-height:48vh;border-radius:12px;border:1px solid #1c2740;background:#0f1729}
    /* Tabelle */
    table{width:100%;border-collapse:collapse;min-width:800px}
    th,td{border-bottom:1px solid #1c2740;padding:8px;text-align:left;white-space:nowrap}
    th{background:#0f1729;position:sticky;top:0;z-index:1}
    td.c{text-align:center}
    #feedback.ok{color:var(--ok)} #feedback.warn{color:var(--warn)} #feedback.err{color:var(--err)}
    .status-erfasst{color:var(--warn);font-weight:600}
    /* Nur der Tabellenbereich kann horizontal scrollen */
    .table-scroll{overflow-x:auto;border:1px solid #1c2740;border-radius:10px}
    /* Visuelles Highlight bei Erfolg */
    .flash-green { animation: flashGreen 600ms ease-in-out; }
    @keyframes flashGreen { 0% { background-color: rgba(34,197,94,0.35); } 100% { background-color: transparent; } }
    /* Kleine Bildschirme: Bedienelemente nicht umbrechen */
    .row > * { white-space: nowrap; }
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0;font-size:18px">VRM Wareneingang – Kamera-OCR</h1>
    <span class="badge">Build v9 (manueller Scan + Scroll-Tabelle)</span>
  </header>

  <main>
    <!-- 1) CSV LADEN -->
    <section class="card">
      <div class="row">
        <input id="file" type="file" accept=".csv,text/csv" />
        <button id="btnLoad" class="primary">CSV übernehmen</button>
        <select id="keyCol" title="Schlüssel-Spalte" disabled></select>
        <select id="qtyCol" title="Mengen-Spalte" disabled></select>
        <select id="lang" title="OCR-Sprache">
          <option value="eng">OCR: Englisch</option>
          <option value="deu">OCR: Deutsch</option>
          <option value="eng+deu" selected>OCR: Englisch+Deutsch</option>
        </select>
        <button id="export" class="primary">Bericht exportieren</button>
      </div>
      <div class="hint">Empfohlen als Schlüssel: <b>Wagennummer</b> (alternativ: <b>LS</b>). Scannen per Button „Jetzt scannen“.</div>
    </section>

    <!-- 2) KAMERA & OCR -->
    <section class="card">
      <div class="row">
        <button id="startCam" class="primary">Kamera starten</button>
        <button id="stopCam">Kamera stoppen</button>
        <button id="scanNow" class="primary">Jetzt scannen</button>
        <label style="margin-left:10px"><input type="checkbox" id="beep" checked> Beep</label>
      </div>

      <div style="margin-top:10px" class="row">
        <div style="flex:1">
          <div class="hint">Letzter Scan:</div>
          <div id="lastScan" style="font-weight:700;font-size:16px">–</div>
          <div id="feedback"></div>
          <div id="statusbar" class="hint">Bereit.</div>
        </div>
      </div>

      <video id="video" autoplay playsinline></video>
      <div class="hint" id="ocrStatus">OCR bereit …</div>
    </section>

    <!-- 3) TABELLE (unten, horizontal scrollbar) -->
    <section class="card">
      <div class="table-scroll">
        <table>
          <thead>
            <tr>
              <th>Schlüssel (gewählte Spalte)</th>
              <th>Artikel (erste Zeile)</th>
              <th class="c">Erwartet</th>
              <th class="c">Gesc.</th>
              <th class="c">Offen</th>
              <th class="c">Status</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </section>

    <!-- 4) LOG -->
    <section class="card">
      <div class="hint">Konsole</div>
      <pre id="log"></pre>
    </section>
  </main>

<script>
// Optionaler Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js?v=9').catch(()=>{});
}

const $ = sel => document.querySelector(sel);
const log = (...a)=>{ const el=$('#log'); el.textContent += a.join(' ') + '\n'; console.log(...a); };

/* ====== CSV ====== */
let headers=[], rows=[];
let expect=new Map(), scanned=new Map(), firstArticle=new Map();
let keyName='LS', qtyName='Bretter';

$('#btnLoad').addEventListener('click', async () => {
  const file = $('#file').files[0];
  if (!file) return alert('Bitte zuerst eine CSV-Datei auswählen.');
  const text = await file.text();
  const delim = detectDelimiter(text);
  const data = parseCSV(text, delim);
  if (!data.length) { alert('CSV ist leer.'); return; }
  headers = data[0].map(h => h.trim());
  rows = data.slice(1);
  log('CSV übernommen. Spalten:', headers.join(' | '));

  const keySel = $('#keyCol'), qtySel = $('#qtyCol');
  keySel.innerHTML=''; qtySel.innerHTML='';
  headers.forEach(h => {
    const o1=document.createElement('option'); o1.value=h; o1.textContent=`Schlüssel: ${h}`; keySel.appendChild(o1);
    const o2=document.createElement('option'); o2.value=h; o2.textContent=`Menge: ${h}`; qtySel.appendChild(o2);
  });
  keyName = headers.includes('Wagennummer') ? 'Wagennummer' : (headers.includes('LS') ? 'LS' : headers[0]);
  keySel.value = keyName;

  if (headers.includes('Bretter')) {
    qtyName = 'Bretter'; qtySel.value='Bretter';
  } else {
    const opt = document.createElement('option'); opt.value='<keine>'; opt.textContent='Menge: <keine>'; qtySel.prepend(opt); qtySel.value='<keine>';
    qtyName = '<keine>';
  }
  keySel.disabled=false; qtySel.disabled=false;
  applyMapping(); status();
});

$('#keyCol').addEventListener('change', e => { keyName=e.target.value; applyMapping(); status(); });
$('#qtyCol').addEventListener('change', e => { qtyName=e.target.value; applyMapping(); status(); });

function applyMapping(){
  expect.clear(); scanned.clear(); firstArticle.clear();
  const kIdx = headers.indexOf(keyName);
  const qIdx = (qtyName && qtyName!=='<keine>') ? headers.indexOf(qtyName) : -1;
  const aIdx = headers.indexOf('Artikelname');

  for (const r of rows) {
    if (kIdx<0 || kIdx>=r.length) continue;
    const key = String(r[kIdx] ?? '').trim();
    if (!key) continue;
    let q = 1;
    if (qIdx>=0 && qIdx<r.length) q = toInt(r[qIdx],1);
    expect.set(key, (expect.get(key)||0) + (q>0?q:1));
    if (!firstArticle.has(key) && aIdx>=0 && aIdx<r.length) firstArticle.set(key, String(r[aIdx] ?? ''));
  }
  renderTable();
  $('#lastScan').textContent='–'; setFeedback('', '');
}

function renderTable(){
  const tb = document.getElementById('tbody');
  tb.innerHTML = '';
  const keys = Array.from(expect.keys()).sort((a,b)=>a.localeCompare(b));
  for (const k of keys){
    const exp = expect.get(k) || 0;
    const done = scanned.get(k) || 0;
    const open = Math.max(exp - done, 0);

    let status = 'offen', cls = '';
    if (done === 0)      { status = 'offen';      cls = ''; }
    else if (done < exp) { status = 'erfasst';    cls = 'status-erfasst'; }
    else if (done === exp){ status = 'ok';        cls = 'ok'; }
    else                 { status = 'überzählig'; cls = 'warn'; }

    const tr = document.createElement('tr');
    tr.dataset.key = k; // für visuelles Highlight
    tr.innerHTML = `
      <td>${escapeHtml(k)}</td>
      <td>${escapeHtml(firstArticle.get(k) || '')}</td>
      <td class="c">${exp}</td>
      <td class="c">${done}</td>
      <td class="c">${open}</td>
      <td class="c ${cls}">${status}</td>
    `;
    tb.appendChild(tr);
  }
}

document.getElementById('export').addEventListener('click', ()=>{
  if (!expect.size) return alert('Kein Datensatz geladen.');
  const out=[["Schlüssel","Artikel (erste Zeile)","Erwartet","Gescant","Offen","Status"]];
  const keys=Array.from(expect.keys()).sort((a,b)=>a.localeCompare(b));
  for (const k of keys){
    const exp=expect.get(k)||0, done=scanned.get(k)||0, open=Math.max(exp-done,0);
    let s='offen'; if (done===0) s='offen'; else if (done<exp) s='erfasst'; else if (done===exp) s='ok'; else s='überzählig';
    out.push([k, firstArticle.get(k)||"", exp, done, open, s]);
  }
  const ts=new Date().toISOString().replace(/[:\-]/g,'').slice(0,15);
  downloadCSV(`wareneingang_report_${ts}.csv`, out);
});

/* ====== OCR / Kamera (manuell) ====== */
let videoStream=null, workerReady=false;
let ocrLang='eng+deu';

document.getElementById('lang').addEventListener('change', e => { ocrLang=e.target.value; setFeedback(`OCR-Sprache: ${ocrLang}`, ''); });

document.getElementById('startCam').addEventListener('click', startCamera);
document.getElementById('stopCam').addEventListener('click', stopCamera);
document.getElementById('scanNow').addEventListener('click', () => {
  const video = $('#video');
  if (video.srcObject) captureAndOCR(video);
  else setFeedback('Kamera ist nicht aktiv.', 'err');
});

async function startCamera(){
  try{
    const video=$('#video');
    videoStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' } });
    video.srcObject = videoStream;
    await ensureWorker();
    setFeedback('Kamera aktiv. Bereit zum Scannen.', '');
    log('Kamera gestartet');
  }catch(e){
    setFeedback('Kamera-Fehler: '+e.message, 'err');
    log('Kamera-Fehler:', e.name, e.message);
  }
}

function stopCamera(){
  if (videoStream){ for (const t of videoStream.getTracks()) t.stop(); videoStream=null; }
  setFeedback('Kamera gestoppt.', '');
}

async function ensureWorker(){
  if (workerReady) return;
  $('#ocrStatus').textContent='Lade OCR … (erster Start 10–20s)';
  if (!window.Tesseract){
    await new Promise((resolve,reject)=>{
      const s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
      s.onload=resolve; s.onerror=reject;
      document.head.appendChild(s);
    });
  }
  window._tessWorker = window._tessWorker || await Tesseract.createWorker();
  await _tessWorker.loadLanguage(ocrLang);
  await _tessWorker.initialize(ocrLang);
  workerReady=true;
  $('#ocrStatus').textContent='OCR bereit.';
}

async function captureAndOCR(video){
  if (!workerReady || !_tessWorker) return;
  const canvas=document.createElement('canvas');
  const w=video.videoWidth, h=video.videoHeight;
  if (!w || !h) return;
  canvas.width=w; canvas.height=h;
  const ctx=canvas.getContext('2d');
  const cw=Math.floor(w*0.9), ch=Math.floor(h*0.6);
  const sx=Math.floor((w-cw)/2), sy=Math.floor((h-ch)/2);
  ctx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
  $('#ocrStatus').textContent='Erkenne Text …';
  const { data:{ text } } = await _tessWorker.recognize(canvas);
  const clean=text.trim().replace(/\s+/g,' ');
  $('#ocrStatus').textContent='Gefundener Text: '+clean;
  checkOCRMatch(clean);
}

// Token-Match: A–Z/0–9, 4–12 Zeichen
function checkOCRMatch(text){
  if (!expect.size) { setFeedback('Bitte zuerst CSV übernehmen.', 'err'); return; }
  const tokens = (text||'').toUpperCase().replace(/[^A-Z0-9]+/g,' ').split(' ').filter(t=>t.length>=4 && t.length<=12);
  const keyMap = new Map(); for (const key of expect.keys()) { if (!key) continue; keyMap.set(String(key).toUpperCase(), key); }

  for (const tok of tokens){
    if (keyMap.has(tok)){
      const key = keyMap.get(tok);
      const prev = scanned.get(key) || 0;
      const done = prev + 1;
      scanned.set(key, done);
      document.getElementById('lastScan').textContent = key;

      const exp = expect.get(key) || 0;
      if (done < exp) { setFeedback(`✅ ${key}: erfasst ${done}/${exp}`, 'warn'); beep(880, 90); flashRow(key); }
      else if (done === exp) { setFeedback(`✅ ${key}: vollständig (${done}/${exp})`, 'ok'); beep(1200, 120); flashRow(key); }
      else { setFeedback(`⚠️ ${key}: ÜBERZÄHLIG (${done}/${exp})`, 'warn'); beep(600, 150); flashRow(key); }

      renderTable(); status();
      if (navigator.vibrate) { navigator.vibrate(80); }
      return;
    }
  }
  setFeedback('❌ Kein Schlüssel im OCR-Text gefunden', 'err');
  beep(300, 140);
}

// Visuelles Highlight der passenden Tabellenzeile
function flashRow(key){
  const row = [...document.querySelectorAll('#tbody tr')].find(tr => tr.dataset.key === key);
  if (!row) return;
  row.classList.remove('flash-green'); // reset, damit Animation neu startet
  void row.offsetWidth;                // Reflow
  row.classList.add('flash-green');
}

/* ====== Status & Feedback ====== */
function status(){
  const totalExp=[...expect.values()].reduce((a,b)=>a+b,0);
  const totalDone=[...scanned.values()].reduce((a,b)=>a+b,0);
  const totalOpen=Math.max(totalExp-totalDone,0);
  $('#statusbar').textContent=`Gesamt: erwartet ${totalExp} • gescannt ${totalDone} • offen ${totalOpen}`;
}
function setFeedback(text, type){
  const f=$('#feedback'); f.textContent=text; f.className=type||'';
}

/* ====== Audio-Beep ====== */
let audioCtx;
function beep(freq=440, dur=100){
  if (!$('#beep').checked) return;
  try{
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.frequency.value = freq; o.type = 'sine';
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur/1000);
    o.stop(now + dur/1000 + 0.02);
  }catch(e){}
}

/* ====== Utils ====== */
function detectDelimiter(text){
  const sample=text.split(/\r?\n/).slice(0,20).join('\n');
  const counts={',':0,';':0,'\t':0,'|':0}; let inQ=false;
  for (let i=0;i<sample.length;i++){ const ch=sample[i];
    if (ch === '"') inQ=!inQ; else if(!inQ && counts.hasOwnProperty(ch)) counts[ch]++; }
  return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
}
function parseCSV(text,delim){
  const rows=[]; let i=0,field='',row=[],inQ=false;
  while(i<text.length){ const ch=text[i];
    if(inQ){ if(ch=== '"'){ if(text[i+1]==='"'){ field+='"'; i+=2; continue;} inQ=false; i++; continue;} field+=ch; i++; continue; }
    if(ch=== '"'){ inQ=true; i++; continue; }
    if(ch=== '\r'){ i++; continue; }
    if(ch=== '\n'){ row.push(field); rows.push(row); field=''; row=[]; i++; continue; }
    if(ch===delim){ row.push(field); field=''; i++; continue; }
    field+=ch; i++;
  } row.push(field); rows.push(row);
  if(rows.length && rows[0].length && rows[0][0] && rows[0][0].charCodeAt(0)===0xFEFF){ rows[0][0]=rows[0][0].slice(1); }
  return rows;
}
function toInt(v, def=0){ if(v==null) return def; const s=String(v).trim().replace(/[€\s]/g,'').replace(/\./g,'').replace(/,/g,'.'); const n=parseFloat(s); return Number.isFinite(n)?Math.max(0,Math.round(n)):def; }
function downloadCSV(filename, rows){
  const csv=rows.map(r=>r.map(x=>{ const s=String(x??''); return /[;"\n,]/.test(s)?`"${s.replace(/"/g,'""')}"`:s; }).join(';')).join('\n');
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; a.click(); URL.revokeObjectURL(a.href);
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])); }
</script>
</body>
</html>
